makeCacheMatrix <- function(x = matrix()) {
# inv will store the cached inverse matrix
inv <- NULL
# Setter for the matrix
set <- function(y) {
x <<- y
inv <<- NULL
}
# Getter for the matrix
get <- function() x
# Setter for the inverse
setinv <- function(inverse) inv <<- inverse
# Getter for the inverse
getinv <- function() inv
# Return the matrix with our newly defined functions
list(set = set, get = get, setinv = setinv, getinv = getinv)
}
# cacheSolve: Compute the inverse of the matrix. If the inverse is already
# calculated before, it returns the cached inverse.
cacheSolve <- function(x, ...) {
inv <- x$getinv()
# If the inverse is already calculated, return it
if (!is.null(inv)) {
message("getting cached data")
return(inv)
}
# The inverse is not yet calculated, so we calculate it
data <- x$get()
inv <- solve(data, ...)
# Cache the inverse
x$setinv(inv)
# Return it
inv
}
B<-matrix(c(1,2,3,4),2,2)
B
B1<-makeCacheMatrix(B)
cacheSolve(B1)
source('~/ProgrammingAssignment2/cachematrix.R')
